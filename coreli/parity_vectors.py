""" Contains the appropriate functions to work with parity vectors and *feasible vectors* (which we call **Compact Representations**). 

For more information on these concepts please refer to "G. J. Wirsching. *The dynamical system generated by the 3n + 1 function.* Springer, Berlin New
York, 1998.", Chapter 2.
"""
import random
from typing import List, Callable
from coreli.base_conversion_routines import *
import coreli.routines as routines
import coreli.modular_routines as modular_routines

class Parvec(object):
    """ Represents a parity vector. A parity vector is a list of 0s and 1s (called `arrows`) representing\
         whether T0 or T1 was used during a finite Collatz trajectory. A parity vector of\
              length :math:`n` corresponds to a Collatz trajectory of length :math:`n+1`.
              
        For instance the trajectory `[3, 5, 8, 4, 2]` is associated to the parity vector `[1, 1, 0, 0]`.

        The `get_first_occurrence` feature is related to this work: `https://arxiv.org/abs/1907.00775\
                 <https://arxiv.org/abs/1907.00775>`_.
    """
    def __init__(self, parvec: List[int]) -> None:
        self.parvec = parvec
        self._check_parvec()

    def _check_parvec(self) -> None:
        """ Verifies that the parity vector contains onlys 0s and 1s. """
        for e in self.parvec:
            if not e in [0,1]:
                raise ValueError('The parity vector {} is not valid.\
                                  It should contain only 0s and 1s'.format(self.parvec))

    @classmethod
    def from_cs(cls, cs: List[int]) -> 'Parvec':
        """ Construct the parity vector associated to a given collatz sequence.

            :Example:
                >>> Parvec.from_cs([3, 5, 8, 4, 2]).parvec
                [1, 1, 0, 0]
        """
        parvec = []
        for e in cs[:-1]:
            parvec.append(e%2)
        return Parvec(parvec)

    @classmethod
    def get_random_parvec(cls, n_parvec: int = 1, max_norm: int = 10, 
                          fixed_norm: bool = False) -> List['Parvec']:
        """ Returns `n_parvec` random parity vectors of norm at most `max_norm`.\
            If `fixed_norm` is True, all parity vectors will be of norm exactly\
            `max_norm`.
        """
        norm = max_norm
        to_return = []
        for _ in range(n_parvec):
            if not fixed_norm:
                norm = random.randint(0, max_norm)
            to_return.append(Parvec([random.choice([0,1]) for _ in range(norm)]))
        return to_return

    @property
    def norm(self) -> int:
        """ Numbers of steps in the parity vector, also called *norm* in  Wirsching.

            :Example:
                >>> Parvec.from_cs([3, 5, 8, 4, 2]).parvec
                [1, 1, 0, 0]
                >>> Parvec.from_cs([3, 5, 8, 4, 2]).norm
                4
        """
        return len(self.parvec)

    @property
    def span(self) -> int:
        """ Number of odd steps in the parity vector, called *length* in Wirsching.

            :Example:
                >>> Parvec.from_cs([3, 5, 8, 4, 2]).parvec
                [1, 1, 0, 0]
                >>> Parvec.from_cs([3, 5, 8, 4, 2]).span
                2
        """
        return sum(self.parvec)

    def get_first_occurrence(self) -> List[int]:
        """ Returns the first occurrence of the parity vector: starts from the\
            smallest integer that is admissible for the parity vector.

            More details on this algorithm in `https://arxiv.org/abs/1907.00775\
                 <https://arxiv.org/abs/1907.00775>`_.

            :Example:
                >>> Parvec([1,1,0]).get_first_occurrence()
                [3, 5, 8, 4]
                >>> Parvec([1,0,1,1,1,0]).get_first_occurrence()
                [9, 14, 7, 11, 17, 26, 13]
                >>> Parvec([0,0,0,1]).get_first_occurrence()
                [8, 4, 2, 1, 2]
        """
        alpha0 = 0
        alpha_minus_1 = 0
        k = 0

        for i, arrow in enumerate(self.parvec):
            if not routines.is_admissible(arrow, alpha_minus_1):
                alpha0 += 2**(i)

            if arrow == 1:
                k += 1

            alpha_minus_1 = modular_routines.T_modular(arrow, k, alpha_minus_1)

        return routines.CS(alpha0, lambda x,n: n == self.norm)

    def get_occurrence(self, i_occ:int = 0) -> List[int]:
        """ Returns the ith occurrence of the parity vector.

            :Example:
                >>> Parvec([1,0,1,1,1,0]).get_occurrence()
                [9, 14, 7, 11, 17, 26, 13]
                >>> Parvec([1,0,1,1,1,0]).get_occurrence(2)
                [137, 206, 103, 155, 233, 350, 175]
        """
        occ = self.get_first_occurrence()

        if i_occ == 0:
            return occ

        alpha_i = (2**(self.norm))*i_occ + occ[0]
        return routines.CS(alpha_i, lambda x,n: n == self.norm)

    def get_Collatz_encoding(self) -> str:
        """ In `https://arxiv.org/abs/1907.00775\
                 <https://arxiv.org/abs/1907.00775>`_ we define the Collatz encoding of \
        a parity vector to be the binary representation of the smallest integer which is\
            admissible for that parity vector.

            :Example:
                >>> Parvec([1,0,1,1,1,0]).get_Collatz_encoding()
                '001001'
                >>> Parvec([1,0,0]).get_Collatz_encoding()
                '101'
        """
        alpha0 = self.get_first_occurrence()[0] 
        return int_to_binary(alpha0,self.norm)

    def to_compact(self):
        """ Returns the compact representation of the parity vector.
        
            :Example:
                >>> Parvec([0,0,0,1]).to_compact().compact
                [3, 0]
                >>> Parvec([0,1,0,0,0,1,1,0,0]).to_compact().compact
                [1, 3, 0, 2]
                >>> Parvec([1,0,0,0,1,0,0,1,1,0,1]).to_compact().compact
                [0, 3, 2, 0, 1, 0]
        """
        parvec_str = ''.join(list(map(str, self.parvec)))
        splt = parvec_str.split('1')
        return CompactRep([len(e) for e in splt])

class CompactRep(object):
    """ Represents the compact representation of a parity vector, called *feasible vector* in Wirsching.

        For instance, the compact representation of the parity vector\
        [0,1,0,0,0,1,1,0,0] is: [1,3,0,2]. Successive 0s are "packed together". See Wirsching for more detail.
    """
    def __init__(self, compact: List[int]) -> None:
        self.compact = compact

    def __str__(self):
        """ In strings, we represent compact representations with () instead of [].
        """
        return str(tuple(self.compact))

    @classmethod
    def get_random_compact(cls, n_compact: int = 1, max_span: int = 10, 
                          fixed_span: bool = False) -> List['CompactRep']:
        """ Returns `n_compact` random compact rep of span at most `max_span`.\
            If `fixed_span` is True, all compact rep will be of norm exactly\
            `max_span`.
        """
        span = max_span
        to_return = []
        for _ in range(n_compact):
            if not fixed_span:
                span = random.randint(0, max_span)
            to_return.append(CompactRep([random.randint(0,100) for _ in range(span+1)]))
        return to_return

    def to_parvec(self) -> 'Parvec':
        """ Converts a compact representation to the equivalent parity vector.
        
            :Example:
                >>> CompactRep([3,0]).to_parvec().parvec
                [0, 0, 0, 1]
                >>> CompactRep([1,3,0,2]).to_parvec().parvec
                [0, 1, 0, 0, 0, 1, 1, 0, 0]
                >>> CompactRep([0,3,2,0,1,0]).to_parvec().parvec
                [1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1]
        """
        parvec = []

        for i, elem in enumerate(self.compact):
            parvec += [0]*elem
            if i != len(self.compact)-1:
                parvec += [1]
        
        return Parvec(parvec)

    @property
    def norm(self) -> int:
        """ Returns the norm of the associated parity vector"""
        return sum(self.compact) + self.span

    @property
    def span(self) -> int:
        """ Returns the span of the associated parity vector"""
        return len(self.compact)-1

#def cs_to_parvec()
