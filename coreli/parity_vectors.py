""" Contains the appropriate functions to work with parity vectors and *feasible vectors* (which we call **Compact Representations**). 

For more information on these concepts please refer to "G. J. Wirsching. *The dynamical system generated by the 3n + 1 function.* Springer, Berlin New
York, 1998.", Chapter 2.
"""
from typing import List, Callable
import coreli.routines as routines
import coreli.modular_routines as modular_routines

class Parvec(object):
    """ Represents a parity vector. A parity vector is a list of 0s and 1s (called `arrows`) representing\
         whether T0 or T1 was used during a finite Collatz trajectory. A parity vector of\
              length :math:`n` corresponds to a Collatz trajectory of length :math:`n+1`.
              
        For instance the trajectory `[3, 5, 8, 4, 2]` is associated to the parity vector `[1, 1, 0, 0]`.
    """
    def __init__(self, parvec: List[int]) -> None:
        self.parvec = parvec
        self._check_parvec()

    def _check_parvec(self) -> None:
        """ Verifies that the parity vector contains onlys 0s and 1s. """
        for e in self.parvec:
            if not e in [0,1]:
                raise ValueError('The parity vector {} is not valid.\
                                  It should contain only 0s and 1s'.format(self.parvec))

    @classmethod
    def from_cs(cls, cs: List[int]) -> 'Parvec':
        """ Construct the parity vector associated to a given collatz sequence.

            :Example:
                >>> Parvec.from_cs([3, 5, 8, 4, 2]).parvec
                [1, 1, 0, 0]
        """
        parvec = []
        for e in cs[:-1]:
            parvec.append(e%2)
        return Parvec(parvec)

    @property
    def norm(self) -> int:
        """ Numbers of steps in the parity vector, also called *norm* in  Wirsching.

            :Example:
                >>> Parvec.from_cs([3, 5, 8, 4, 2]).parvec
                [1, 1, 0, 0]
                >>> Parvec.from_cs([3, 5, 8, 4, 2]).norm
                4
        """
        return len(self.parvec)

    @property
    def span(self) -> int:
        """ Number of odd steps in the parity vector, called *length* in Wirsching.

            :Example:
                >>> Parvec.from_cs([3, 5, 8, 4, 2]).parvec
                [1, 1, 0, 0]
                >>> Parvec.from_cs([3, 5, 8, 4, 2]).span
                2
        """
        return sum(self.parvec)

    def get_first_occurrence(self) -> List[int]:
        """ Returns the first occurrence of the parity vector: starts from the\
            smallest integer that is admissible for the parity vector.

            More details on this algorithm in `https://arxiv.org/abs/1907.00775\
                 <https://arxiv.org/abs/1907.00775>`_.

            :Example:
                >>> Parvec([1,1,0]).get_first_occurrence()
                [3, 5, 8, 4]
                >>> Parvec([1,0,1,1,1,0]).get_first_occurrence()
                [9, 14, 7, 11, 17, 26, 13]
                >>> Parvec([0,0,0,1]).get_first_occurrence()
                [8, 4, 2, 1, 2]
        """
        alpha0 = 0
        alpha_minus_1 = 0
        k = 0

        for i, arrow in enumerate(self.parvec):
            if not routines.is_admissible(arrow, alpha_minus_1):
                alpha0 += 2**(i)

            if arrow == 1:
                k += 1

            alpha_minus_1 = modular_routines.T_modular(arrow, k, alpha_minus_1)

        return routines.CS(alpha0, lambda x,n: n == self.norm)

    def get_occurrence(self, i_occ:int = 0) -> List[int]:
        """ Returns the ith occurrence of the parity vector.

            :Example:
                >>> Parvec([1,0,1,1,1,0]).get_occurrence()
                [9, 14, 7, 11, 17, 26, 13]
                >>> Parvec([1,0,1,1,1,0]).get_occurrence(2)
                [137, 206, 103, 155, 233, 350, 175]
        """
        occ = self.get_first_occurrence()

        if i_occ == 0:
            return occ

        alpha_i = (2**(self.norm))*i_occ + occ[0]
        return routines.CS(alpha_i, lambda x,n: n == self.norm)

    def get_Collatz_encoding(self) -> str:
        """ In `https://arxiv.org/abs/1907.00775` we define the Collatz encoding of \
        a parity vector to be the binary representation of the smallest integer which is\
            admissible for that parity vector.
        """
        return ''

class CompactRep(object):
    """ Represents the compact representation of a parity vector, called *feasible vector* in Wirsching.
    """
    pass

#def cs_to_parvec()
